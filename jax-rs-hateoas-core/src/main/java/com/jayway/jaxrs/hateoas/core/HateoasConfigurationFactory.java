package com.jayway.jaxrs.hateoas.core;

import com.jayway.jaxrs.hateoas.CollectionWrapperStrategy;
import com.jayway.jaxrs.hateoas.HateoasLinkInjector;
import com.jayway.jaxrs.hateoas.HateoasVerbosity;
import com.jayway.jaxrs.hateoas.HateoasViewFactory;
import com.jayway.jaxrs.hateoas.support.DefaultCollectionWrapperStrategy;
import com.jayway.jaxrs.hateoas.support.StrategyBasedLinkInjector;
import com.jayway.jaxrs.hateoas.support.DefaultHateoasViewFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Map;

import static org.apache.commons.lang.Validate.notEmpty;

/**
 * Helper factory to create Hateoas configuration classes
 *
 * @author Kalle Stenflo
 */
public class HateoasConfigurationFactory {

    private static final Logger logger = LoggerFactory.getLogger(HateoasConfigurationFactory.class);

    /**
     * If set this will determine the verbosity of the links generated by this
     * application
     * <p/>
     * The instance may be a String that contains either one or more
     * names from the enum {@link com.jayway.jaxrs.hateoas.HateoasOption} class separated by ';', ','
     * or a single verbosity name defined in {@link com.jayway.jaxrs.hateoas.HateoasVerbosity}.
     * <p/>
     *
     * @see com.jayway.jaxrs.hateoas.HateoasVerbosity
     * @see com.jayway.jaxrs.hateoas.HateoasOption
     */
    public static final String PROPERTY_HATEOAS_VERBOSITY = "com.jayway.jaxrs.hateoas.HateoasVerbosity";

    /**
     * If set specifies the implementation class of the {@link com.jayway.jaxrs.hateoas.HateoasLinkInjector}
     * <p/>
     * The type of this property must be a String that is a Class name,
     * and the Class must a sub-class of
     * {@link com.jayway.jaxrs.hateoas.HateoasLinkInjector}.
     * <p/>
     * If not set the default {@link com.jayway.jaxrs.hateoas.HateoasLinkInjector} implementation will be used.
     */
    public static final String PROPERTY_HATEOAS_LINK_INJECTOR = "com.jayway.jaxrs.hateoas.HateoasLinkInjector";

    /**
     * If set specifies the implementation class of the {@link com.jayway.jaxrs.hateoas.CollectionWrapperStrategy}
     * <p/>
     * The type of this property must be a String that is a Class name,
     * and the Class must a sub-class of
     * {@link com.jayway.jaxrs.hateoas.CollectionWrapperStrategy}.
     * <p/>
     * If not set the default {@link com.jayway.jaxrs.hateoas.CollectionWrapperStrategy} implementation will be used.
     */
    public static final String PROPERTY_HATEOAS_COLLECTION_WRAPPER_STRATEGY = "com.jayway.jaxrs.hateoas.CollectionWrapperStrategy";

    /**
     * If set specifies the implementation class of the {@link com.jayway.jaxrs.hateoas.HateoasViewFactory}
     * <p/>
     * The type of this property must be a String that is a Class name,
     * and the Class must a implement  {@link com.jayway.jaxrs.hateoas.HateoasViewFactory}.
     * <p/>
     * If not set the default {@link com.jayway.jaxrs.hateoas.HateoasViewFactory} implementation will be used. Note that this
     * implementation will not produce a view, only return the model provided.
     */
    public static final String PROPERTY_HATEOAS_VIEW_FACTORY = "com.jayway.jaxrs.hateoas.HateoasViewFactory";

    

    
    @SuppressWarnings("unchecked")
    public static HateoasViewFactory createHateoasViewFactory(Map<String, Object> props, String... defaults){
        String implClass = getProperty(props, PROPERTY_HATEOAS_VIEW_FACTORY, DefaultHateoasViewFactory.class.getName(), defaults);
        try {
            return (HateoasViewFactory)Class.forName((String) implClass).newInstance();
        } catch (Exception e) {
            throw new RuntimeException("Failed to instantiate " + implClass);
        }
    }


    @SuppressWarnings("unchecked")
    public static HateoasLinkInjector<Object> createLinkInjector(Map<String, Object> props, String... defaults) {
        String implClass = getProperty(props, PROPERTY_HATEOAS_LINK_INJECTOR, StrategyBasedLinkInjector.class.getName(), defaults);
        try {
            return (HateoasLinkInjector<Object>)Class.forName((String) implClass).newInstance();
        } catch (Exception e) {
            throw new RuntimeException("Failed to instantiate " + implClass);
        }
    }

    @SuppressWarnings("unchecked")
    public static CollectionWrapperStrategy createCollectionWrapperStrategy(Map<String, Object> props, String... defaults) {
        String implClass = getProperty(props, PROPERTY_HATEOAS_COLLECTION_WRAPPER_STRATEGY, DefaultCollectionWrapperStrategy.class.getName(), defaults);
        try {
            return (CollectionWrapperStrategy)Class.forName((String) implClass).newInstance();
        } catch (Exception e) {
            throw new RuntimeException("Failed to instantiate " + implClass);
        }
    }

    public static HateoasVerbosity createVerbosity(Map<String, Object> props, String... defaults) {
        String verbosityConfig = getProperty(props, PROPERTY_HATEOAS_VERBOSITY, "MAXIMUM", defaults);
        HateoasVerbosity verbosity = HateoasVerbosity.findByName(verbosityConfig);
        if (verbosity != null) {
            return verbosity;
        }
        return HateoasVerbosity.valueOf(verbosityConfig);
    }


    private static String getProperty(Map<String, Object> props, String property, String systemDefault, String... defaults){
        notEmpty(property, "property must not be null or empty.");
        String propertyValue = (String) props.get(property);
        if(propertyValue == null || propertyValue.trim().isEmpty()){
            if(defaults != null && defaults.length > 0){
                propertyValue = defaults[0];
            } else {
                propertyValue = systemDefault;
            }
        }
        return propertyValue;
    }
}
